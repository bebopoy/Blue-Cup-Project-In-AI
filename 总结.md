# 考点总结

[历年大学\【真题模拟 1】中文词库分词-1.ipynb] 词库中的最大匹配问题

[历年大学\【真题模拟 2】模型热更新-1.ipynb] 互斥锁、请求体、返回体、json

---

## 文件取用

### txt 文件

**分行取内容**：
extend()保持结构不变 与 append()会直接加入

- extend 拓展保持数据类型不发生改变，append 直接将变量加入其中，可能破坏数据的结构导致出错

[示例查看：历年大学\【真题模拟 7】onnx 模型量化-1.ipynb]

1.构建同义词

```python
diction ={}
with open(filepath, 'r',encoding='utf-8') as f:
    for line in f:
        line.strip() #删除回车，“str”
        words = line.strip().split('r') #删除回车，以','划分,"list"
        for word in words:
            diction[word]=words
return diction
```

2.构建词库

- set 是创建集合，集合的特点内容不重复
- & | - ^ ： 交 并 前有后无的 先并集后减去交集
- set.add() 添加单个元素
- set.upgrade( {"google", "runoob", "apple"} ) 添加多个元素

```python
    dictionary = set()
    with open('words.txt', 'r', encoding='utf-8') as f:
        for line in f:
            word = line.strip()
            dictionary.add(word)
```

### pkl 模型文件：加载与使用

- 一定是 open(modelpath,'rb') 二进制打开为 f，model = pickle.load(f)

  1.pickle：加载与推理

```python
import pickle

current_model = 'svm_1.pkl'
with open(current_model,'rb') as f:
    model = pickle.load(f)

output = model.predict(inputs)

```

2.torch: 加载与推理
情况 1：

- 注意，一定是使用 model.state_dict()

- 一般来说会失败，要求 svm.pkl 的内容与模型的结构完全一致

```python

torch.save(model.state_dict(), 'svm.pkl') # 也可以是'svm.pth'

model = torch.load('svm.pkl')
```

情况 2：

- 注意，一定是使用 model.state_dict()

- 可能会成功，要求 svm.pkl 的内容与模型的结构完全一致，题目中明显没有定义相关模型即废弃

```python

torch.save(model.state_dict(), 'svm.pkl') # 也可以是'svm.pth'

# 从 实例化 到 加载参数 到 load_state_dict(state_dict = )
class model_diy(model.nn)
    def ___init__(self):
        super(model_diy, self).__init__()

    def forward(self, input):

model_object = model_diy()
state_dict = torch.load('svm.pkl')
model_object.load_state_dict(state_dict = state_dict)

# 也可 model_object.load_state_dict(torch.load('svm.pkl'))
```

### csv 文件

### torch 权重

### onnx 模型

## 数学计算实现

### 范数

### 矩阵

### 普通 np 实现，以 ndarray 代图片

1.缩放/插值

```python
old_weight, old_width = image.shape

# 先计算尺寸变化比例
width_scale = new_width/old_width
weight_scale = new_weight/old_weight

# 创新的图像
new_image = np.empty((new_width, new_weight),dtype = )
# 映射关系实现
for i in range(new_height):
    for j in range(new_width):
        raw_height_postion = int(i / height_scale)
        raw_width_postion = int(j / width_scale)

        new_image[i,j] = image[raw_height_postion,raw_width_postion]
```

2.卷积操作,滤波
![alt text](assets/总结/image.png)

```python
old_height, old_width = image.shape

new_image = np.zeros(image.shape)
edge = int((kernel_size - 1) / 2)

for i in range(old_height):
    for j in range(old_width):

        element = 0
        no_noneNum = 0
        for x in range(-edge, edge + 1, 1):
            for y in range(-edge, edge + 1, 1):
                if(0 <= (i+x) < old_height) and (0 <= (j+y) <old_width):
                    new_element = image[i+x,j+y]
                    no_noneNum += 1
                else:
                    new_element = 0

                element += new_element
        new_image[i,j] = element / no_noneNum

return new_image
```

## 模型定义/转换/训练/选择

### 定义

1.teacher/student

```python

class TeacherModel(nn.model):
    def __init__(self):
        super(TeacherModel, self).__init__():
        self.model = nn.Sequential(
            nn.Linear(784, 512),
            nn.Relu(),
            nn.Linear(512, 256),
            nn.Relu(),
            nn.Linear(256, 128),
            nn.Relu(),
            nn.Linear(256, 10)
            nn.softmax(dim = 1 )
        )

    def forward(self, x):
        return self.model(x)

class StudentModel(nn.Module):
    def __init__(self):
        super(StudentModel, self).__init__()
        self.model = nn.Sequential(
        #TODO
        nn.Linear(784, 512),
            nn.ReLU(),
            nn.Linear(512, 10),
            nn.Softmax(dim=1)
        )

    def forward(self, x):
        return self.model(x)

def train_teacher(model, optimizer, citerion,train_loader):
    model.train()
    for images, labels in train_loader:
        optimizer.zero_grad()
        output = model(images.view(image.size(0),-1))
        loss = citerion(output, labels)

        loss.backard()
        optimizer.step()

def train_student(teacher_model, student_model,optimizer, critertion, distillation_loss,train_loader, model_path='./student_model.pth'):
    teacher_model.eval()
    student.model.train()
    for images,labels in train_loader:

        optimizer.zero_grad()
        teacher_output = teacher_model(images.view(images.size(0), -1)).detach()

        student_output = student_model(images.view(images.size(0), -1))
        loss = criterion(student_output, labels) + 0.5 * distillation_loss(student_output, teacher_output)
        loss.backard()
        optimizer.step()

    torch.save(student_model.state_dict(),model_path)
```

### 转换

1. torchvision.models 库中的 resnet18
   加载 pth state_dict，转化为 onnx

```python
import torchvision
import torchvision.models as models

def onnx_model_transfer(input, input_model_path, out_model_path):
    resnet_model =models.resnet18()
    state_dict = torch.load(input_model_path)
    resnet_model.load_state_dict(state_dict = state_dict)

    resnet_model.eval()
    torch.onnx.export(resnet_model, out_model_path)
```

### 训练

### 选择

## 部署/后端 flask

### lock()互斥锁

引入 from threading import Lock

- 先实例化，mylock = Lock()
- 在互斥操作前，使用 with mylock:

numpy 转为 list ,tolist()

```python
# 引入
from threading import Lock
import pickle

# 实例化Lock
mylock = Lock()

@app.route('/predict', methods=['POST'])
def predict():
    with model_lock:
        inputs = request.get_json()['input']
        output = model.predict(inputs).tolist()

        return jsonify({'current_model':current_model, 'output': output})

@app.route('/update', methods=['POST'])
def update():
    with model_lock:
        new_model = request.get_json()['model']
        if new_model in ['svm_1.pkl', 'svm_2.pkl', 'svm_3.pkl']:
            global current_model, model
            current_model = new_model
            with open(current_model, 'rb') as f:
                model = pickle.load(f)
            return current_model, 200

        return 'Invalid model', 400

```

### 请求与返回体 json

```python
from falsk import Falsk, request, jsonify

    return jsonify({'current_model':current_model, 'output':output})
    # 化字典为json

    return current_model, 200
    return current_model, 400

```
